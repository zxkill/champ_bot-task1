# Автономная навигация робота Webots по узким коридорам

Проект демонстрирует устойчивую навигацию дифференциального робота в лабиринте Webots:
скрипт автоматически обнаруживает проходы по данным лидара, выравнивается по центру коридора и
быстро проводит робота через узкие участки. Такой подход одинаково полезен для
SEO-запросов вроде *Webots corridor navigation*, *lidar corridor detection* и *autonomous maze driving*.

## Ключевые возможности

- **Поиск проходов**: модуль `tools.py` разбирает lidar-облако и оценивает ширину доступных коридоров.
- **Плавное следование**: класс `CorridorFollower` формирует линейные и угловые скорости с учётом ограничений ускорений.
- **Мгновенное применение команд**: `demo.py` отправляет рассчитанные `v` и `w` напрямую в контроллер, благодаря чему робот не "задумывается" и уверенно входит в найденный проём.
- **Подробное логирование**: все шаги снабжены русскоязычными сообщениями для удобной диагностики.
- **Тестовое покрытие**: в репозитории присутствуют модульные тесты, проверяющие геометрию коридоров и корректность управления.
- **Гистерезис ширины проёма**: параметр `width_tolerance` в `corridor_fits` компенсирует шум лидара, чтобы коридоры не «пропадали» во время манёвра.

## Подготовка окружения

1. Установите **Webots v.R2025a** (актуальная стабильная версия): [https://cyberbotics.com/#download](https://cyberbotics.com/#download).
2. Клонируйте репозиторий `https://git.robot.cybertech.ai/champ_bot/task1`.
3. Установите зависимости Python (при необходимости):
   ```bash
   pip install -r requirements.txt
   ```

## Запуск симуляции лабиринта

Главный мир: `worlds/cobra_flex_demo.wbt`. После открытия Webots автоматически поднимет контроллер `udp_diff`,
который слушает команды на `127.0.0.1:5555/UDP` и отдаёт телеметрию на `127.0.0.1:5600/TCP или UDP`.

Команды запуска для популярных платформ:

- **macOS**
  ```bash
  /Applications/Webots.app/Contents/MacOS/webots --stdout --stderr ./worlds/cobra_flex_demo.wbt
  ```
- **Windows**
  ```bash
  "C:\\Program Files\\Webots\\webots.exe" --stdout --stderr .\\worlds\\cobra_flex_demo.wbt
  ```
- **Linux**
  ```bash
  /webots/webots --stdout --stderr ./worlds/cobra_flex_demo.wbt
  ```
  или
  ```bash
  snap run webots --stdout --stderr ./worlds/cobra_flex_demo.wbt
  ```

## Запуск клиента навигации

1. Убедитесь, что симуляция уже идёт и контроллер `udp_diff` загружен.
2. Выполните:
   ```bash
   python demo.py
   ```
3. В терминале появятся сообщения вида `Коридор (i0, i1) ... -> команды: v=..., w=...`. Робот начнёт уверенно проходить найденный коридор.

Клиент использует протокол UDP для команд и автоматически восстанавливает движение при появлении нового безопасного прохода.
Дополнительно включено отладочное сообщение, если коридор отвергается из-за недостаточной ширины или глубины — это помогает быстро понять, почему робот остановился.
При необходимости можно подобрать величину допущения через переменную окружения `WIDTH_TOLERANCE` (значение в метрах, по умолчанию 0.02).
Если робот уже вошёл в коридор и сенсор зафиксировал кратковременное сужение,
используйте вспомогательные переменные окружения:

- `WIDTH_RECOVERY_MARGIN` — дополнительная поблажка (по умолчанию 0.04 м), позволяющая временно удерживать коридор, даже если ширина просела на пару сантиметров.
- `CORRIDOR_RECOVERY_HOLD_SEC` — длительность удержания с расширенным допуском (по умолчанию 0.6 с), чтобы робот успел выровняться и вернуть запас ширины.

## Формат обмена данными

- **Команда движения** — два числа `float32` (`linear_x`, `angular_z`) в формате little-endian, отправляются на `127.0.0.1:5555/UDP`.
- **Телеметрия** — заголовок `b"WBTG"`, затем девять значений `float32` (одометрия, скорости, гироскоп) и массив расстояний лидара.

Пример отправки команды на Python:

```python
import socket, struct

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
packet = struct.pack("<2f", 0.3, 0.0)  # ехать вперёд 0.3 м/с без поворота
sock.sendto(packet, ("127.0.0.1", 5555))
```

## Соревновательный сценарий «две комнаты»

Для гонки с ограниченным полем зрения лидара (45°) подготовлен отдельный
скрипт `race_runner.py`. Он использует заранее подобранные опорные точки,
чтобы робот без промедления покинул правую комнату, аккуратно прошёл мостик
и занял белый прямоугольник в левой комнате.

1. Убедитесь, что симуляция Webots уже запущена и контроллер `udp_diff`
   активен.
2. Выполните:
   ```bash
   python race_runner.py
   ```
3. В логе появятся сообщения вида `Цель=(x, y), v=..., w=...`. Они
   демонстрируют текущую цель, командные скорости и запас до ближайшего
   препятствия.

Маршрут хранится в `RaceRoute.default()`: при необходимости можно изменить
координаты точек и скорости под другую конфигурацию трассы.

Чтобы робот не застревал во вращении при большом скоплении препятствий, в
`NavigatorConfig` предусмотрены параметры `avoidance_max_correction` и
`turn_priority_threshold`. Первый ограничивает максимальную поправку по
угловой скорости от избегания, второй заставляет навигатор сохранять знак
поворота, если регулятор курса требует резкого разворота. При адаптации
маршрута под другую трассу рекомендуется скорректировать эти значения вместе
с `avoidance_gain`, чтобы добиться ровного прохода без рывков и разворотов
не в ту сторону.

Для старта в тесной комнате добавлены параметры `forward_clearance_distance`
и `blocked_turn_speed`. Первый определяет, какой свободный зазор лидара
считается достаточным для движения вперёд. Если дистанция меньше, робот
фиксирует паузу и выполняет активный разворот до тех пор, пока пространство
не освободится. Порог `blocked_turn_speed` задаёт минимальную угловую
скорость в таком режиме, благодаря чему робот мгновенно разворачивается и не
пытается протиснуться в узкую щель. Чтобы подавить «дребезг» показаний
лидара, добавлен гистерезис `clearance_release_margin`: он требует создать
небольшой дополнительный запас перед тем, как навигатор снимет блокировку и
перейдёт к поступательному движению. Для управляемых поисков коридора
используется пара настроек `scan_fixed_direction` и `scan_full_rotation`.
По умолчанию `scan_fixed_direction = None`, поэтому навигация доверяет знаку
ошибки курса и подсказкам лидара: робот оценивает, где больше свободного
пространства, и крутится туда. Если трасса требует строгого вращения только
влево или только вправо, задайте `scan_fixed_direction = ±1`. В оба режима
включается `scan_full_rotation`: если за 360° не нашлось безопасного проёма,
навигатор фиксирует остановку и пишет ошибку в логах — отличный индикатор
узких мест.

Дополнительные опции `blocked_direction_bias_threshold` и
`blocked_yaw_bias_threshold` усиливают динамический режим: они помогают быстро
подобрать «правильную» сторону по лидара и угловой ошибке, что полезно для
SEO-сценариев вроде *adaptive corridor search* или *maze runner lidar logic*.
Когда нужен полностью детерминированный поворот, «липкая» стратегия с
`scan_fixed_direction` сохраняет прежнее поведение: робот крутится только в одну
сторону, держит детальный лог («Полный круг ...», «Фронтальный проход очищен ...»)
и немедленно едет вперёд, как только датчики увидели устойчивый коридор. Такой
подход стабильно выводит участника на белый прямоугольник и хорошо
индексируется по запросам *Webots corridor race* и *fast lidar room escape*.

## Тестирование

Проект сопровождается автотестами. Для быстрой проверки того, что алгоритм поиска и прохода через коридор работает корректно, выполните:

```bash
pytest --cov
```

Рекомендуется запускать тесты перед каждым коммитом — так проще отслеживать регрессии и поддерживать высокое покрытие.
